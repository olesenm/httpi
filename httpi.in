~check ISNTINSTALLEDYET

******* HEY! THIS ISN'T THE REAL WEBSERVER! DON'T RUN THIS! RUN CONFIGURE!

Thanks.
~
~
#!DEF_PERL
$VERSION = "0.99 (DEF_CONF_TYPE/DEF_ARCH)";

# HTTPi Hypertext Tiny Truncated Process Implementation
# Copyright 1999 Cameron Kaiser # All rights reserved # Please read LICENSE
# Do not strip this copyright message.

$logfile = "DEF_ACCESS_LOG";
$path = "DEF_HTDOCS_PATH";
$sockaddr = 'S n a4 x8';

~check MDEMONIC
if ($pid = fork()) { exit; }
$0 = "dhttpi: binding port ...";
$bindthis = pack($sockaddr, DEF_AF_INET, DEF_TCP_PORT, DEF_INADDR_ANY);
socket(S, DEF_PF_INET, DEF_SOCK_STREAM, DEF_IPPROTO_TCP);
setsockopt(S, DEF_SOL_SOCKET, DEF_SO_REUSEADDR, 1);
bind(S, $bindthis) || die("$0: while binding port DEF_TCP_PORT:\n\"$!\"\n");
listen(S, DEF_SOMAXCONN);
$0 = "dhttpi: connected and waiting DEF_IP_ADDR:DEF_TCP_PORT";
~
$0 = "httpi: handling request";
~

~check STATIOS
$statiosuptime = time();
~
~

~check MFALSE

*** The content types hash is a simple associative array with extensions for
    keys and MIME types for values.

~
~
%content_types =
	("html" => "text/html",
	 "bin" => "application/octet-stream",
	 "class" => "application/octet-stream",
	 "wav" => "audio/x-wav",
	 "htm" => "text/html",
	 "txt" => "text/plain",
	 "gif" => "image/gif",
	 "zip" => "application/x-zip-compressed",
	 "gz"  => "application/x-gzip",
	 "jpeg" => "image/jpeg",
	 "jpg" => "image/jpeg");
~check MFALSE

*** The restrictions matrix is documented in the manual. The keys are the
    filepaths and the values are the matrices themselves.

*** The host redirect matrix is also documented, the keys being the simulated
    host names and the values being the redirect prefix.
~
~
~check MRESTRICTIONS
%restrictions =
	("/nw" => "^10\.##^Mozilla#MSIE",
	 "/status" => "####voyeur:daNrZR3TcSwD2");
		# See documentation for interpreting this string.
~
~
~check NAMEREDIR
%nameredir =
	("stockholm" => "http://stockholm.ptloma.edu",
	 "httpi.ptloma.edu" => "http://stockholm.ptloma.edu/httpi");
~
~

$headers = <<"EOF";
Server: HTTPi/$VERSION
MIME-Version: 1.0
EOF

###############################################################
# WHITE HATS ONLY BELOW THIS POINT -- SEE DOCUMENTATION FIRST #
###############################################################

sub sock_to_host {
~check MFALSE

*** Turn STDIN's socket address into an IP and, if we're lucky, a host name.

~
~
	local($sock) = getpeername(STDIN);

	return (undef, undef, undef) if (!$sock);
	local($AFC, $port, $thataddr, $zero) = unpack($sockaddr, $sock);
	local($ip) = join('.', unpack("C4", $thataddr));
~check MHOSTNAMES
	local($hn) = gethostbyaddr($thataddr, 2) || $ip;
	return ($hn, $port, $ip);
~
	return ($ip, $port, $ip);
~
}

sub htsponse {
~check MFALSE

*** Return an HTTP status code and explanation, along with any collected
    headers.

~
~
	($currentcode, $currentstring) = (@_);
	return if (0+$httpver < 1);
	local($what) = <<"EOF";
~check HTTP11WAIT
HTTP/$httpver $currentcode $currentstring
~
HTTP/1.0 $currentcode $currentstring
~
${headers}Date: $rfcdate
EOF
	$what =~ s/\n/\r\n/g;
	print stdout $what;
~check HTTP11WAIT
	&hthead("Connection: Keep-Alive") if (0+$httpver > 1 || $keep);
~
~
}

sub hthead {
~check MFALSE

*** Add headers to the HTTP output, and/or terminate the header block.

~
~
	local($header, $term) = (@_);
	return if (0+$httpver < 1);
	print stdout "$header\r\n" , ($term) ? "\r\n" : "";
}

sub htcontent {
~check MFALSE

*** Spew content, with the proper content type header and length header.

~
~
	local($what, $ctype) = (@_);
	($contentlength) = length($what);
	&hthead("Content-Length: $contentlength");
	&hthead("Content-Type: $ctype", 1);
	return if ($method eq 'HEAD');
	print stdout $what;
}

sub log {
~check MFALSE

*** Log the request.

~
~
 	if (open(J, ">>$logfile")) {
		local $q = $address . (($variables) ? "?$variables" : "");
		$contentlength += 0;
		$contentlength = 0 if ($method eq 'HEAD');
		local ($hostname, $port) = &sock_to_host();
		$hn = $hn || "-";
		$httpuser = $httpuser || "-";
~check ORIG_LOG
		print J <<"EOF";
$hostname $httpuser - [$date] "$method $q HTTP/$httpver" $currentcode $contentlength "$httpref" ""
~
~
~check GROSS_LOG
		print J <<"EOF";
$hostname $httpuser - [$date] "$method $q HTTP/$httpver" $currentcode $contentlength "$httpref" "$httpua"
~
~
~check TERSE_LOG
		print J <<"EOF";
$hostname $httpuser - [$date] "$method $q HTTP/$httpver" $currentcode $contentlength "" ""
~
~
EOF
		close(J); }
	}

~check MFALSE

*** Various signal handlers (bye for SIGALRM and dead for __DIE__).

~
~

sub bye { exit; }

sub dead {
	&htsponse(500, "Server Error");
	&hterror("Server Error", <<"EOF");
While handling a request for resource $address, the server crashed. Please
attempt to notify the administrators.
<p>Useful(?) debugging information:
<pre>
@_
</pre>
EOF
	&log; exit;
}

$SIG{'__DIE__'} = \&dead;
$SIG{'ALRM'} = \&bye;

~check MFALSE

*** Main loop.

~
~
~check MDEMONIC
sub master {
	$0 = "dhttpi: handling request";
~
~
# $sock = getpeername(STDIN);
$rfcdate = scalar gmtime;
($dow, $mon, $dt, $tm, $yr) = ($rfcdate =~
	m/(...) (...) (..) (..:..:..) (....)/);
$dt += 0; $yr += 0;
$rfcdate = "$dow, $dt $mon $yr $tm GMT";
$date = scalar localtime;
($dow, $mon, $dt, $tm, $yr) = ($date =~
	m/(...) (...) (..) (..:..:..) (....)/);
$dt += 0;
$dt = substr("0$dt", length("0$dt") - 2, 2);
$date = "$dt/$mon/$yr:$tm DEF_TIME_ZONE"; 

select(STDOUT); $|=1; $address = 0; 
~check MCANALARM
alarm 10;
~
~
while (<STDIN>) {
	if(/^(GET|HEAD|POST)\s+([^\s]+)\s+([^\s\r\l\n]*)/) {
		$method = $1;
		$address = $2; 
		$httpver = $3;
		$httpref = '';
		$httpua = '';
		$httpver = ($httpver =~ m#HTTP/([0-9]\.[0-9]+)#) ?
			($1) : (0.9);
		next unless ($httpver < 1);
	} else {
~check HTTP11WAIT
		$keep = 1 if (/^Connection: Keep-Alive/i);
~
~
		s/[\r\l\n\s]+$//;
~check NAMEREDIR
		(/^Host: (.+)/i) && ($httphost = $1) && ($httphost =~
			s/:\d+$//);
~
~
		(/^Referer: (.+)/i) && ($httpref = $1);
		(/^User-agent: (.+)/i) && ($httpua = $1);
		(/^Content-length: (\d+)/i) && ($ENV{'CONTENT_LENGTH'} =
			$httpcl = $1);
		(/^Content-type: (.+)/i) && ($ENV{'CONTENT_TYPE'} =
			$httpct = $1);
~check MRESTRICTIONS
		(/^Authorization: Basic (.+)/i) && ($httprawu = $1);
~
~
		next unless (/^$/);
	}
	if (!$address) {
		&htsponse(400, "Bad Request");
		&hterror("Bad Request",
			"The server cannot understand your request.");
		&log; exit;
	}
~check NAMEREDIR
	if ($httphost && $httphost ne 'DEF_SERVER_HOST') {
		if ($nameredir{$httphost}) {
			&hterror301("$nameredir{$httphost}$address");
		}
		&hterror404; &log; exit;
	}
~
~
	($address, $variables) = split(/\?/, $address);
	1 while $address =~ s#/\./#/#;
	1 while $address =~ s#^/?\.\./#/#;
	1 while $address =~ s#/[^/]+/\.\./#/#;
~check MRESTRICTIONS
	$fail = 0;
	J: foreach(sort { length $a <=> length $b }
			keys %restrictions) {
		next if ($address !~ /^$_/);
		($allowip, $denyip, $allowua, $denyua, $auser) =
			split(/#/, $restrictions{$_});
		if ($allowip || $denyip) {
			($hn, $port, $ip) = &sock_to_host();
			($allowip && $ip !~ /$allowip/) && ($fail = 1,
				last J);
			($denyip && $ip =~ /$denyip/) && ($fail = 1,
				last J);
		}
		($allowua && $httpua !~ /$allowua/) &&
			($fail = 2, last J);
		($denyua && $httpua =~ /$denyua/) &&
			($fail = 2, last J);
	}
	if ($fail) {
		&htsponse(403, "Forbidden");
		if ($fail == 1) {
			&hterror("Forbidden (Client Disallowed)", <<"EOF");
Your network address (<i>$ip</i>) is not allowed to access this resource.
EOF
			&log; exit;
		} else {
			&hterror("Forbidden (Browser Disallowed)", <<"EOF");
The browser you are using (<i>$httpua</i>) is not capable of or
is not allowed access to this resource.
EOF
			&log; exit;
		}
	}
	if ($auser) {
		$httprawu =~ tr#A-Za-z0-9+/##cd;
		$httprawu =~ tr#A-Za-z0-9+/# -_#;
		$httprawu = unpack("u", pack("c", 32+0.75*length($httprawu))
			. $httprawu);
		($httpuser, $httppw) = split(/:/, $httprawu);
		$fail = 1;
		foreach $user (split(/,/, $auser)) {
			($user, $pw) = split(/:/, $user);
			($fail = 0, last) if ($user eq $httpuser &&
				crypt($httppw, substr($pw, 0, 2)) eq $pw);
		}
		if ($fail) {
			$httpuser = '';
			&htsponse(401, "Authorization Required");
			&hthead("WWW-Authenticate: Basic realm=\"$address\"");
			&hterror("Authorization Required", <<"EOF");
You must provide a username and password to use this resource. Either you
entered this information incorrectly, or your browser does not know how to
present the credentials required.
EOF
			&log; exit;
		}
	}
~
~

######## ADD YOUR HANDLERS OR MODULES HERE #########

~check STATIOS
	if ($address eq '/status') {
		&htsponse(200, "OK");
		$contentlength = 0; # kludge
		&log;
		if(open(S, $logfile)) {
			seek(S, -3000, 2);
			undef $/;
			$logsnap = <S>;
			$logsnap =~ s/^[^\n]+\n//s if
				(length($logsnap) > 2999);
			close(S);
		}
		$p = (time() - $statiosuptime);
		$rps = $p/$statiosreq;
		$d = int($p / 86400); $p -= $d * 86400;
		$h = int($p / 3600); $p -= $h * 3600;
		$m = int($p / 60); $s = $p - ($m * 60);
		("0$s" =~ /(\d{2})$/) && ($s = $1);
		("0$m" =~ /(\d{2})$/) && ($m = $1);
		$h +=0; $d += 0;
		$suptime = scalar localtime $statiosuptime;
		&htcontent(<<"EOF", "text/html");
<html>
<head>
<title>
HTTPi Status for Server DEF_SERVER_HOST
</title>
</head>
<body bgcolor = "#ffffff" text = "#000000" vlink = "#0000ff" link = "#0000ff">
<h1>HTTPi Server Status (<code>$VERSION</code>)</h1>
<h3><code>DEF_SERVER_HOST</code> on DEF_IP_ADDR:DEF_TCP_PORT</h3>
<b>Started at:</b> $suptime<br>
<b>Uptime:</b> $d days, $h:$m:$s<br>
<b>Last request time:</b> $statiosltr<p>
<b>Requests received:</b> $statiosreq<br>
<b>Average time between requests:</b> ${rps}s
<p>
<b>Most recent requests:</b>
<form action = "/status" method = "post">
<textarea name = "bletch" rows = "8" cols = "70">
$logsnap
</textarea>
</form>
<hr>
<address>maintained by <a href =
"http://httpi.ptloma.edu/">httpi/$VERSION</a></address>
</body>
</html>
EOF
		exit;
	}
~
~
	$raddress = "$path$address"
~check MUSERFS
		if ($raddress = $address, $raddress !~
			s#/~([^/]+)#(getpwnam($1))[7]."/public_html"#e);
~
	;
~
	&hterror301("http://DEF_SERVER_HOST$address/")
		if ($address !~ m#/$# && -d $raddress);
	$raddress = "${raddress}index.html" if (-d $raddress);
	if(!open(S, $raddress)) { &hterror404; } else {
		if (-x $raddress) {
			$currentcode = 100;
			&log;
			if (!$<) {
				($x,$x,$x,$x,$uid,$gid) = stat(S);
				(!$uid || !$gid) &&
					die "executable is root-owned";
~check CANDOSETRUID
				$< = $uid || die "can't set uid";
				$( = $gid || die "can't set gid";
~
~
				$> = $uid || die "can't set effuid";
				$) = $gid || die "can't set effgid";
			}
			($hostname, $port, $ip) = &sock_to_host();
			$ENV{'REQUEST_METHOD'} = $method;
			$ENV{'SERVER_NAME'} = "DEF_SERVER_HOST";
			$ENV{'SERVER_PROTOCOL'} = "HTTP/$httpver";
			$ENV{'SERVER_SOFTWARE'} = "HTTPi/$VERSION";
~check MDEMONIC
			$ENV{'SERVER_PORT'} = "DEF_TCP_PORT";
			$ENV{'SERVER_URL'} = "http://DEF_SERVER_HOST:DEF_TCP_PORT/";
~
			($x, $ENV{'SERVER_PORT'}, $x, $x) = unpack($sockaddr,
				getsockname(STDIN));
			$ENV{'SERVER_URL'} = "http://DEF_SERVER_HOST:$ENV{'SERVER_PORT'}/";
~
			$ENV{'SCRIPT_FILENAME'} = $raddress;
			$ENV{'SCRIPT_NAME'} = $address;
			$ENV{'REMOTE_HOST'} = $hostname;
			$ENV{'REMOTE_ADDR'} = $ip;
			$ENV{'REMOTE_PORT'} = $port;
			$ENV{'QUERY_STRING'} = $variables;
			$ENV{'HTTP_USER_AGENT'} = $httpua;
			$ENV{'HTTP_REFERER'} = $httpref;
~check MDEMONIC
			if ($pid = fork()) { exit; } else {
~
~
~check MHTTPERL
				require $raddress;
				exit;
~
				if ($method eq 'POST') { # needs stdin
					open(W, "|$raddress") || die
						"can't POST to $raddress";
					read(STDIN, $buf, $httpcl);
					print W $buf;
					exit;
				}
				exec "$raddress", "$variables";
				die "exec() returned -1";
~
~check MDEMONIC
			}
~
~
		}
		($x,$x,$x,$x,$x,$x,$x,$x,$x,$mtime) = stat(S);
		$mtime = scalar gmtime $mtime;
		($dow, $mon, $dt, $tm, $yr) =
			($mtime =~ m/(...) (...) (..) (..:..:..) (....)/);
		$dt += 0; $yr += 0;
		$ctype = 0;
		foreach(keys %content_types) {
			if ($raddress =~ /\.$_$/) {
				$ctype = $content_types{$_};
			}
		}
		$ctype ||= "text/plain";
		&htsponse(200, "OK");
		&hthead("Last-Modified: $dow, $dt $mon $yr $tm GMT");
		$j = $/; undef $/; $q = <S>; $/ = $j; close(S);
		&htcontent($q, $ctype);
	}
	&log;
~check HTTP11WAIT
	exit if (!$keep);
	alarm DEF_TIME_OUT;
~
	exit;
~
}

exit;
~check MDEMONIC
}
~
~

sub hterror {
	local($errstr, $expl) = (@_);
	&htcontent(<<"EOF", "text/html");
<html>
<body>
<h1>$errstr</h1>
$expl
<hr>
<address><a href = "http://httpi.ptloma.edu/">httpi/$VERSION</a>
by Cameron Kaiser</address>
</body>
</html>
EOF
	}

sub hterror404 {
	&htsponse(404, "File Not Found");
	&hterror("File Not Found",
		"The resource $address was not found on this system.");
}

sub hterror301 {
	&htsponse(301, "Moved Permanently");
	&hthead("Location: @_");
	&hterror("Resource Moved Permanently",
		"This resource has moved <a href = \"@_\">here</a>.");
	$keep = 0; &log; exit;
}

~check MFALSE

*** accept() loop that spawns the single child for accepting connections
    in Demonic HTTPi.

~
~
~check MDEMONIC
for (;;) {
	$addr=accept(NS,S);
	$statiosltr = scalar localtime;
	$statiosreq++;
	if ($pid = fork()) {
		$0 = "dhttpi: waiting for child process";
		waitpid($pid, 0);
		$0 = "dhttpi: on DEF_IP_ADDR:DEF_TCP_PORT, last request " .
			scalar localtime;
	} else {
		$0 = "dhttpi: child switching to socket";
		open(STDIN, "<&NS");
		open(STDOUT, ">&NS");
		&master;
		exit;
	}
}
~
~
