<html>
<head><title>HTTPi Programming Manual</title></head>
<body bgcolor = "#ffffff" vlink = "#0000ff" link = "#0000ff" text = "#000000">
<a href ="./"><img src = "pix/httpismall.gif" alt = "[&lt;&lt;]" height = 32
width = 91 border = 0></a><i>Back to the main page</i>
<hr>
<img src = "pix/httpibig.gif" align = right alt = " ">
<h1>Programming Manual</h1>
HTTPi was designed first and foremost to be a hacker's webserver that was
easily understood, easily patched and trivially maintainable -- thus this
document.
<p>
The Programming Manual
describes HTTPi internals to people interested in writing or patching
their own applications into HTTPi. <b>Perpetually under construction.
Additions and suggestions, user patches, etc., are welcomed to the code
base.</b> However, I or an authorised maintainer reserve the right to choose
what gets checked in. Remember the philosophy: "more with less" :-)
<p>
Send your questions or difficulties to <b><a href =
"mailto:httpi@stockholm.ptloma.edu">httpi@stockholm.ptloma.edu</a></b>.
<p>
<a name = "cnfg"><h3>Getting Started with the
HTTPi <tt>configure</tt> Script</h3></a>
If you didn't read this page thoroughly, you would probably just go to
where your configure script dropped the Perl executable and merrily edit
it in-place. And it would probably work, too. Well, I've got three words for
that:
<p>
<b><i>Don't do it!</i></b>
<p>
Why?
If you decide to make configuration changes at a later date, or upgrade
to a later version of HTTPi, guess what happens to your changes when
configure runs again? You got it: completely obliterated. That's why
HTTPi has a primitive <code>make</code> system of sorts built into the
<code>configure</code> script suite. (Again, please recall there
are multiple <code>configure</code> scripts; replace
<code>configure</code> with the appropriate one for your setup.)
By working in with the configure scripts, you can make changes to your
heart's content <i>and</i> carry them across configuration changes and
server updates. <i>So don't edit the HTTPi executable directly!</i>
<p>
There are three files in the HTTPi distribution that you need to worry about.
These files are glommed together at configure-time. (Previous versions of
HTTPi before 1.2 had them all in <code>httpi.in</code>. If you are,
for some pathological reason, patching an old version, then remember that
all changes must be made there, and that some features might not be
available to you.) The files are:
<p><ul>
<li><code>httpi.in</code>, the master server code. Modules maintained
in the standard distribution, like STATIOS, are also here.
<li><code>modules.in</code>, the repository for user modules. All user
modules should be put in this file. You can use this file when you're
upgrading to keep the same modules in your next build.
<li><code>uservar.in</code>, the user variables file. Certain configuration
variables, like the restriction matrix, content types and IP-less
virtual hosting, are kept here. Again, you can use this file when you're
upgrading to keep the same settings in your next build.
</ul>
<p>
We'll discuss making those changes later. How do you use
<code>configure</code>?
<p>
If you have a settings transcript from a previous run
of <code>configure</code> (usually named something like
<code>transcript.0.configure</code>), you can use that to save typing, and
<code>configure</code> will get its answers from that.
Just do
<p>
<code>% perl configure -d filename</code>
<p>
where <code>filename</code> is the transcript file, either one automatically
made by <code>configure</code>, or one of your own. If you leave out the
filename, the default answer to questions will be used.
<i>That's it.</i> (If you
are using Demonic HTTPi, you will need to kill the old process(es) and
start the new one for changes to take effect. Don't worry; when
run in this mode <code>configure</code> doesn't change your <code>inetd</code>
or <code>xinetd</code> configuration files.)
<p>
Otherwise, just run the appropriate configure script as usual and answer
the necessary questions.
<p>
Naturally, none of the <code>*.in</code> files are
runnable Perl; they're teased and
twisted by <code>configure</code> into your runtime object, since
<code>configure</code> actually contains a miniature pre-processor. Lines like
this:
<pre>
~check SOMETHING
~
~
</pre>
are exactly identical to
<pre>
#ifdef SOMETHING
#else
#endif
</pre>
(except that they can't be nested)
and have exactly the same semantics as they do in the standard C
pre-processor. These are used to determine build-time code based on 
settings you select and on system options (like whether your system
supports <code>setruid()</code> -- AIX doesn't, Linux does).
There's also a mystical <code>~insert</code> that has similar semantics
to <code>#include</code>, except that you can't yet nest it either.
There are also defines in the <code>httpi.in</code> file that
you should be able to match up with questions asked during the
<code>configure</code> process. Unless you're a white hat, don't mess
with them or preprocessor directives.
<p>
In short, <code>configure</code> is your <code>make</code> processor.
Use it, love it. You could modify the script in place, but
<code>configure</code> is, we think, much friendlier, and you'll thank us
for it later.
<p>
<table width = 100% border = 0 cellpadding = 5 cellspacing = 2><tr>
<td bgcolor = "#e0e0ff">
<b>Hint:</b> If you hopelessly destroy your <code>*.in</code> files, the
<i>real</i> Unix <code>make</code> can rescue you. Assuming the
<code>stock/</code> directory is still intact, <code>make revert</code>
will replace all your <code>*.in</code> files with the standard
distribution versions. Sorry, this works in 1.2 and up only.
</td></tr></table>
<a name = "uvar"><h3>Making User Variable Changes</h3></a>
Several important globals reside in <code>uservar.in</code>. If you want
to add extra headers, change the MIME types reported for a file
extension, alter the rules for the <a href = "serve.html#secu">restriction
matrix</a> or add IP-less
<a href = "serve.html#htho">virtual hosts</a>, this is the file to
change. (Before 1.2, these globals were in <code>httpi.in</code>.)
<p>
To make these changes, simply edit <code>uservar.in</code> and make
the needed alterations to the globals. Only these intentionally
user-configurable globals are kept in this file; all others will be
in <code>httpi.in</code> and should be reserved for white hats. Then
run <code>configure</code> again, as described
<a href = "#cnfg">above</a>, to update your executable.
<p>
The list of HTTPi globals is <a href = "#glob">listed later in this
manual</a>.
<a name = "hand"><h3>Writing In Your Own Custom Handlers</h3></a>
Adding internal services to HTTPi is very simple to do: simply put them
into <code>modules.in</code> (before 1.2, into <code>httpi.in</code>). At
that point the HTTP request has been decoded,
you have all of the needed globals defined, and you're at the point where
HTTPi needs to determine what the browser should get back.
<p>
For example, if you inserted this snippet of code:
<pre>
	if ($address eq "/whoami") {
		&htsponse(200, "OK");
		&htcontent(&lt;&lt;"EOF", "text/html");
&lt;html&gt;
&lt;body&gt;
Hello, $variables!
&lt;/body&gt;
&lt;/html&gt;
EOF
		&log; exit;
	}
</pre>
and run <code>configure</code> again as described
<a href = "#cnfg">above</a> to make a new executable, then your
new HTTPi will internally be able to handle URLs like
<code>http://bletch/whoami?Cameron</code>, and respond with a cheery,
friendly response. (Here's information on the <a href = "#glob">global
variables</a> and <a href = "#func">functions</a> used here.)
<p>
The STATIOS module in Demonic HTTPi is an example of a more functional
patch to the HTTPi code. Check it out for examples of what you can do.
Since it is a module included in the standard distribution, it is in
<code>httpi.in</code>, but it could just as easily be run from
<code>modules.in</code> as well.
<p>
In earlier versions,
at this point in HTTPi's execution, no attempt had been made to find a
valid file specification or check the restriction matrix and it
was assumed you had
a good idea of what your routine likes and doesn't like. As of 0.99, the
restriction matrix checks now come first, so you may protect a module with,
say, a password or an IP range restriction by putting an entry in the
restriction matrix. In fact, this is how STATIOS
is implemented by default. 
<p>
<a name = "func"><h3>Functions in HTTPi</h3></a>
<b>Networking functions</b> (ordered by appearance)
<p>
<dl>
<dt><code>sub sock_to_host</code>
<dd>This function takes the result of <code>getpeername(STDIN)</code> and
turns it into a hostname. Used for the <code>log</code> subroutine and
executable support. Normally handled by similarly named functions in
<code>Socket.pm</code> and like-minded modules, but HTTPi has its own socket
support built-in. Unlike 0.1, the current version is hardcoded to use the
<code>STDIN</code> filehandle. A list of (<code>hostname, port, IP</code>) is
returned; if hostname lookups are off, IP addresses
are returned in both the hostname and IP address sections.
</dl><p>
<b>HTTP response functions</b> (ordered by appearance)
<dl>
<dt><code>sub htsponse</code>
<dd>This function takes two parameters, the HTTP response code (e.g. 200,
404, 500, etc.), and a string; it then sends to the client the HTTP
response header, the HTTPi custom headers, and the current date. Globals
<code>$currentcode</code> and <code>$currentstring</code> are set with the
response code and string respectively. This function silently exits if the
HTTP version of the client is 0.9.
<dt><code>sub hthead</code>
<dd>This function takes two parameters, the header and an optional
termination flag. The header is sent to the client, and if the termination
flag is true (!= 0), the termination sequence <code>"\r\n"</code> is also
sent to indicate the end of headers. The header will automatically have
<code>"\r\n"</code> appended to it. This function silently exits if the
HTTP version of the client is 0.9.
<dt><code>sub htcontent</code>
<dd>This function takes two parameters, the content itself (as a scalar)
and the MIME content type. Global <code>$contentlength</code> is set with
the length of the content scalar. The content length and content
type are sent to the client with the <code>hthead</code> function (the
content type having the termination flag set), and the content is then
dumped to the client unless the current request method is <code>HEAD</code>.
</dl><p>
<b>HTTPi-internal functions</b> (ordered by appearance)
<dl>
<dt><code>sub log</code>
<dd>This function takes no parameters. It writes CERN log entries to the
file specified in the global <code>$logfile</code>, and utilises globals
<code>$hostname $httpref $date $method $address $variables $httpver $httpua
$currentcode</code> and <code>$contentlength</code>, depending on the
logging option specified during the <code>configure</code> process.
<dt><code>sub bye</code>
<dd>This function is called by default when HTTPi receives a
<code>SIGALRM</code>. Currently, it just silently terminates HTTPi.
<dt><code>sub dead</code>
<dd>This function is called by default when HTTPi receives signals that
would cause Perl to terminate (through the <code>__DIE__</code> psuedo
handler). It logs a 500 error through <code>htsponse</code> and prints an
error message with <code>hterror</code>.
<dt><code>sub hterror</code>
<dd>This function is used to display the default formatted HTTPi error
message. It assumes that <code>htsponse</code> has already been called to
set the proper HTTP response code. It takes two arguments, a title and an
explicatory string, then calls <code>htcontent</code> with an Apache-like
formatted dump containing the title and explanation.
<dt><code>sub hterror401, hterror302</code>
<dd>These are internal error subroutines that simply set error codes and
fall through to <code>hterror</code> with their messages.
</dl>
<a name = "glob"><h3>Important Globals in HTTPi</h3></a>
<table width = 100% cellpadding = 5 cellspacing = 2 border = 0>
<tr><td bgcolor = "#ffe0e0">
<b><code>&lt;S&gt;</code> and <code>&lt;NS&gt;</code> are HTTPi's control
filehandles. Don't mess with them unless you know what you're doing!</b>
</td></tr></table><p>
<h4>Globals maintained in <a href = "#uvar"><code>uservar.in</code></a></h4>
<dl>
<dt><code>$headers</code>
<dd>A simple scalar containing additional headers to be sent to the client.
<dt><code>%content_types</code>
<dd>A hash with file extensions as the keys and their respective MIME-types
for values. Additional file extensions should be added here.
<dt><code>%restrictions</code>
<dd>The restriction matrix, specifying security options for HTTPi resources.
See the <a href = "serve.html#secu">manual</a> for the format of values in this
hash.
<dt><code>%nameredir</code>
<dd>The HTTP name redirect. See the <a href = "serve.html#htho">manual</a>
for the format of values in this hash.
</dl>
<h4>Globals maintained in <code>httpi.in</code></h4>
<dl>
<dt><code>$logfile, $path</code>
<dd>Respectively, the absolute path of the logfile and the absolute path of
the document directory. Set on startup.
<dt><code>$currentcode, $currentstring</code>
<dd>Respectively, the numerical HTTP response code (e.g. 200, 404, etc.), and
the provided string (e.g. "OK", "File Not Found", etc.) Set by
<code>htsponse</code>.
<dt><code>$contentlength</code>
<dd>Length of content passed to client. Set by <code>htcontent</code>.
<dt><code>$rfcdate</code>
<dd>The current date and time, in GMT and RFC format.
<dt><code>$date</code>
<dd>The current local date and time, in CERN log format.
<dt><code>$method, $address, $httpver</code>
<dd>Respectively, the HTTP method (e.g. GET), requested resource, and HTTP
version (0.9, 1.0, 1.1). Set after receipt of a valid request from the
client. <code>$address</code> is explicitly set to zero before a request
is read so that a "false" <code>$address</code> will trip an error 400.
<dt><code>$raddress</code>
<dd>The real, fully-qualified path to the resource desired, if it can be
instantiated. Only set after restriction matrix checks are passed.
<dt><code>$variables</code>
<dd>The variables passed via the GET method to the server. Passed to an
executable script through command line arguments and the
<code>QUERY_STRING</code> environment variable.
<dt><code>$httpref</code>
<dd>Current HTTP referer, as specified by client (- if none given). Set after
receipt of a valid <code>Referer</code> header from the client.
<dt><code>$httpua</code>
<dd>Current HTTP user agent/browser string, as specified by client (- if none
given). Set after receipt of a valid <code>User-Agent</code> header from the
client.
<dt><code>$httprawu, $httpuser, $httppw</code>
<dd>Respectively, the <code>base64</code>-encoded <code>Authorization</code>
header string, and the decoded user and temporary space for the clear-text
password. The
first is set on receipt of a valid <code>Authorization</code> header; the
others only set after restriction matrix checks are passed.
<dt><code>$mtime</code>
<dd>Last modify date of the currently selected resource as indicated by
<code>$address</code>; set after successfully verifying resource's existence
and a successful <code>stat()</code>, in <code>ctime()</code> format.
</dl>
<a name="inpl"><h3>Inline Perl with the <code>&lt;perl&gt;</code> Tag</h3></a>
The inline Perl module, introduced in HTTPi 1.0, is simultaneously
the most useful and the most abhorrent feature of HTTPi. As much as it
affords you power and flexibility, it also adds a modicum of security
leaks, idiosyncracies and stability issues, and that's why it's not
enabled by default. The warnings below are just the ones <i>the
programmer</i> knows of.
<p>
In short, you can execute arbitrary Perl code inside any document with an
<code>.sht</code>, <code>.shtm</code> or <code>.shtml</code> extension
by placing it within <code>&lt;perl&gt;&lt;/perl&gt;</code> tags. Whatever
your code <code>return</code>s gets displayed to the client.
If you have been <s>stupid</s> bold enough to try the inline Perl option,
be advised of several important issues:
<ul>
<li>You have a tremendous security hole if you enable the user filesystem.
Any user can do just about any Perl operation with the webserver's UID.
<li>You can do <i>almost</i> anything in the Perl tags that you can do in
regular Perl.
<li>You have a tremendous security hole if you enable the user filesystem.
Any user can do just about any Perl operation with the webserver's UID.
<li>You have complete access to the server internals within the Perl tag.
While you cannot affect the server itself or crash it, since you're in a
child process and not the Demonic server or <code>(x)inetd</code>, you can
seriously tank the current instance. You can also make complete use of all
globals, functions and states, and manipulate them to any possible extent.
<li>You have a tremen ... get the point by now?
</ul>
Here's <a href = "sperl.shtml">a brief example of inline Perl</a> that
demonstrates grabbing HTTPi internals, calling HTTPi internal functions
and some Perl expressions. (Code is provided.)
<p>
The page above (<code>sperl.shtml</code>) is very simple and easy, and
armed with the list of globals and functions above, you can manipulate them
in any way you see fit. Of course,
you're not limited to evaluating arbitrary expressions. Try this (code
also provided):
<p>
<b>Did you like Mission: Impossible?</b>
<a href = "imf.shtml?yes">Yes</a> |
<a href = "imf.shtml?no">No</a>
<p>
The code responsible for the above page (<code>imf.shtml</code>) introduces
two functions
that only are added to HTTPi when you enable preparsing. These functions
allow you to store up output into a buffer so you can "print" without
messing up HTTPi's output stream. This is important because your inline Perl
is executing before HTTPi has completely finished emitting headers, and
a naked <code>print</code> will corrupt the HTTP headers and probably cause
some client confusion.
So, instead of <code>print</code>ing, call <code>&amp;output</code> with the
string, which will emit into a buffer <code>$fbuf</code> (or do this
yourself). When you're done, just <code>return &amp;flush();</code>, which
returns and flushes the buffer. You can see this in <code>imf.shtml</code>, so
look at it if you haven't already.
<p>
Errors get caught by HTTPi's <code>__DIE__</code> handler. Of course, if
this bugs you, you could alter this right in your inline Perl by introducing
an anonymous subroutine reference. However, a much better way would be to
rebuild a custom HTTPi yourself with a new handler rather than make such a
change "locally".
<p>
It has been mentioned that there are some things you cannot do in inline Perl.
One of them is, as stated, using <code>print</code> (or, for that matter,
<code>warn</code>). Note that you can use <code>print</code> to print to a
filehandle, but just not to <code>stdout</code>. You also cannot have
a literal <code>&lt;/perl&gt;</code> or <code>&lt;perl&gt;</code> in your
code, since the preparser is
not too bright; you'll need to cleverly escape it or break it up, which
shouldn't be too hard.
(It is fully possible to have an inline Perl block create another inline
Perl block, which will be executed as if it were there in the first place.
The possibilities for recursion are entertaining and somewhat disturbing,
so this exercise is left to the reader.)
<p>
Also, anything that will affect the server process will
probably cause unforseen results. If you decide to <code>use</code> or
<code>require</code> arbitrary code in your inline Perl block, make sure
it doesn't conflict with HTTPi. While you can't break the master server or
bring it down, thanks to process isolation, you will probably get very
inexplicable results out of your document if your module starts treading on
HTTPi's rather large namespace (and vice versa). In general, loading modules in
inline Perl blocks is not recommended: for such an application, use an
executable instead.
<hr>
<address>Cameron Kaiser</address>
</body>
</html>
