<html>
<head><title>HTTPi Installation/User's Manual</title></head>
<body bgcolor = "#ffffff" vlink = "#0000ff" link = "#0000ff" text = "#000000">
<a href ="./"><img src = "pix/httpismall.gif" alt = "[&lt;&lt;]" height = 32
width = 91 border = 0></a><i>Back to the main page</i>
<hr>
<img src = "pix/httpibig.gif" align = right alt = " ">
<h1>Installation/User's Manual</h1>
<a name = "ins"></a>
<h3>Installation and Configuration</h3>
<h4>What you'll need</h4>
<ul><li>Perl 5, though you can probably very easily make it run under Perl 4
(signal handlers might need to be tweaked, and there's a couple Perl5-only
constructions, but that's it). No additional
modules, not even the ones included with the distribution, are
required -- you can make do with just the executable, which is in fact
exactly the setup <code>stockholm</code> is using. If you don't have Perl,
you can get versions from <a href = "http://www.perl.com/">Perl.com</a>.
<li><code>inetd</code> or a moral equivalent. If you have the resources, I
heartily recommend <a
href = "http://synack.net/xinetd/"><code>xinetd</code></a>, a blindingly
fast <code>inetd</code> replacement (I run it here). It's very secure and
offers gallons of features, and you'll get out of the box 25% increase in
speed (according to my unofficial, over-my-lunch-break benchmarks).
Unfortunately, I am not aware of any <code>inetd</code> clones for Windows
or Macintosh, but I'm sure there are some. You'll definitely need one, because
HTTPi does not offer operation as a daemon currently, and you will need to
configure your <code>inetd</code> clone to run HTTPi by hand.
<li>Root access, because <code>/etc/inetd.conf</code> and
possibly also <code>/etc/services</code>, or <code>/etc/xinetd.conf</code>,
need to be modified, unless you have
a very permissive/stupid system administrator. :-)
</ul>
<h4>Installation and Initial Configuration</h4>
Run the appropriate <code>configure</code> script in the distribution. If you
have <code>inetd</code>, run <code>configure.inetd</code>; if you have
<code>xinetd</code>, run <code>configure.xinetd</code>; if you have neither
one, run <code>configure.generic</code>. <b>From this point on, when you
see <code>configure</code>, replace it with the <code>configure.*</code>
script appropriate for your setup.</b>
<p>
Note that no changes can be made to <code>inetd</code>'s or
<code>xinetd</code>'s configuration files if you don't run the appropriate
<code>configure</code> as root.
<p>
Invoke the appropriate script under Perl:
<pre>
# perl configure
</pre>
The configure script figures out system settings and builds a custom version
of HTTPi for you. The <code>inetd</code> version will also add the necessary
lines to
<code>/etc/services</code> and <code>/etc/inetd.conf</code>, provided you
have the appropriate permission; the <code>xinetd</code> version will add
the necessary lines to <code>/etc/xinetd.conf</code>, provided you have the
appropriate permission.
<p>
After running <code>configure</code>, you are left with a transcript file
(named something like <code>configure.transcript.0</code>), which you can
pass to <code>configure</code> with the <code>-d</code> option to save
a lot of typing later. See the <a href = "program.html">Programming Manual</a>.
<h4>Special Note on <code>configure.generic</code></h4>
<code>configure.generic</code> simply builds an executable. It does <i>no</i>
installation. You must connect it with your inetd or equivalent manually.
Please send me details of what you do to <a href = 
"mailto:httpi@stockholm.ptloma.edu"><b>httpi@stockholm.ptloma.edu</b></a>
so I can add support for it in later versions.
<h4>Putting Another Copy On Another Port (<code>configure.inetd</code>
and <code>configure.xinetd</code>)</h4>
This is done with the <code>configure</code> script and is invoked the same
way. Depending on how you answer the questions, the <code>configure</code>
script will either build a new HTTPi for the new port, or have the old HTTPi
map to both the previous port and this port.
<h4>Changing The Configuration Later</h4>
The <code>configure</code> script does the initial configuration for you.
Should you wish to change settings later, you may need to edit
<code>inetd/xinetd</code>'s files and/or or re-run <code>configure</code>.
Some settings are HTTPi-internal.
<ul>
<li><b><i>Can be configured by re-running the configuration script.</i></b><P>
The following options can be re-configured by re-running the configuration
script and making sure that the <code>configure</code>
script overwrites the old build of the server.
<p>
<ul>
<li><b>Setting the location for documents</b>
<li><b>Setting the location of the log file</b> If you are not running
HTTPi as root, you will need to make sure that the log file or directory
structure is writable to that user.
<li><b>HTTP/1.1 settings (both enabled/disabled and timeout)</b>
<li><b>Turning on/off the restriction matrix</b> Note that this does not
actually change the values of the matrix. See below.
</ul>
<p>
<li><b><i>Require editing files after running</i></b> <code>configure</code><p>
The following options require removing lines from <code>/etc/inetd.conf</code>
(for <code>inetd</code> users) or from <code>/etc/xinetd.conf</code> (for
<code>xinetd</code> users), after running the configure script.
<p>
In all cases, simply remove the lines previously added by
<code>configure</code> from the file, making
sure that the most recently added lines are still there.
<p>
<ul>
<li><b>Changing the UID of the server</b>
<li><b>Changing the number of processes</b> (<code>xinetd</code> only)
<li><b>Changing from single-to-multi processes</b> (<code>inetd</code> only)
<li><b>Changing the TCP port of the server</b>
For <code>inetd</code> only:
This option may require removing old services from <code>/etc/services</code>,
particularly if this file gets lengthy.
</ul>
<p>
<li><b><i>Require editing of HTTPi itself</i></b><p>
More information on this is in the <a href = "program.html">Programming
Manual</a>.<p>
To make these changes, load the <code>httpi.in</code> into your favourite
editor and follow the appropriate directions below.
After making the changes, re-run <code>configure</code> and pass it the
<code>-d</code> option and the
name of the transcript with your desired settings in it (usually something
like <code>perl configure -d configure.transcript.0</code>).
This will overwrite your old build with the new one. Again, please read
the section specifically on this in the <a href = "program.html">Programming
Manual</a>.
<p>
<ul>
<li><b>Adding content types</b> HTTPi by default serves up MIME types for
.html, .htm, .txt, .gif, .jpg, .gz and .zip. Add new content types
to the <code>%content_types</code> hash; be sure to follow the format used
in the file. Content types HTTPi doesn't know how to handle are dumped as
text/plain.
<br>
<li><b>Changing the restriction matrix</b> See the section on HTTPi security.
<p>
</ul>
</ul>
<a name = "ser"></a>
<h3>Document Serving and Executable Support</h3>
HTTPi follows a simple rule. If the requested file is readable and exists, it
loads it and displays it. If the requested file is executable by the current
uid, it runs it instead. Everything else gets a 404 error.
Therefore, all you need to do to serve documents is make sure that HTTPi can
read it. If HTTPi is running as root, no worries; if it is running as nobody,
make sure you
<pre>
% chmod ugo+r {filename}
</pre>
so that it can see it, and
<pre>
% chmod ugo+rx {directory}
</pre>
on directories. Naturally, all documents must be in the documents directory
HTTPi is looking in, to ensure that naughtyness like
<a href = "/../../../etc/passwd">/../../../etc/passwd</a> doesn't work.
Good thing, too.
<p>
Unlike just about every other webserver, if you don't have an
<code>index.html</code> file in a directory, you'll get an error, not a
directory tree. This is to save program code and server size, and also
offers a modicum of security so that people can't just riffle your files.
<p>
Requests have to be received within ten seconds of startup, after which the
socket is closed. This prevents
people from opening up socket after socket to try DoS attacks on you.
Ten seconds is probably more than any client needs, of course.
<h4>Executables</h4>
As mentioned, HTTPi supports executable programs of a fashion, but not as
CGI, though some interface features are common.
<p>
When a file being requested is executable by HTTPi's uid, it sets a few
environment variables and <code>exec()</code>s into the executable instead
(unlike other webservers which may fork a process). If HTTPi is running as
root, it gives the executable the egid and euid of the executable's owner.
It does not act like
CGI: <i>you must explicitly set an HTTP response code</i> and <i>you do not
have all the CGI environment variables at your disposal</i>. Think of it as
a very stripped down NPH-CGI environment, where no headers are provided you.
<p>
The file <code>noodle</code>, included with the distribution in the
<code>tools/</code> directory, allows you to
see what happens. <code>chmod</code> it executable (e.g.
<pre>
% chmod ugo+x noodle
</pre>
), pop it in the documents directory, and access it as a regular resource
(try it <a href = "noodle?this+is+a+variable&q=here+is+another">on this
server</a> and see for yourself). It
will display its uid, gid, euid, egid, arguments and environments. You are
provided the <code>REMOTE_HOST</code>, <code>REMOTE_ADDR</code>,
<code>REMOTE_PORT</code>, <code>QUERY_STRING</code>,
<code>HTTP_USER_AGENT</code> and <code>HTTP_REFERER</code> environment
variables. There is no POST support in the current version.
<p>
CGIs that use GET will probably translate just fine. You will need to add an
extra header to explicitly set an HTTP response code, i.e. add
<pre>
HTTP/1.1 200 OK
</pre>
as the first line of whatever output the CGI spews. CGIs need not have the
<code>.cgi</code> extension, and they don't have to be in any particular
directory save the document one (i.e. there is no explicit
<code>/cgi-bin</code> directory).
<p>
Because HTTPi has already ceased to exist by the time the executable starts,
there is no way it can know if the executable succeeded or failed. 
Executables appear in the log file with a status code of 100 instead of 200,
302 or 500, the normal codes seen associated with executables.
<a name = "sec"></a>
<h3>HTTPi Security and the Restriction Matrix</h3>
<b>This is only applicable if you have enabled the restriction matrix
facility when you built your executable with <code>configure</code>.</b>
<p>
Since HTTPi lends itself to adding a quick webserver wrapper around
applications, a frequent use for HTTPi is as a cheap interface to a network
monitor or some data acquisition tool. Equally frequently, this data is
sensitive.
<p>
HTTPi has an allow/deny authorization scheme called the <i>restriction
matrix</i>, a hash in the program that allows the user to create restrictions
for a particular directory or resource to certain network addresses or even
user agents, browsers, or clients. <b>Warning: Perl knowledge required
below this point.</b>
<p>
The restriction matrix is hard-coded into HTTPi. Here's a sample entry (in
fact, the default one that is included in HTTPi):
<pre>
%restrictions =
        ("/nw/" => "^10\.##^Mozilla#MSIE");
</pre>
This restriction matrix says that for all resources in <code>/nw/</code>, only
addresses 10.*.*.* are allowed, and of that set, only browsers that report a
user agent string of Mozilla (Netscape) and do not have MSIE. By now it should
be obvious that this is nothing more than four regular expressions concatenated
together with #s, in this order:
<p>
<ul>
<li>allowed hosts (IP numbers only)
<li>denied hosts (IP numbers only)
<li>allowed user agents/browsers
<li>denied user agents/browsers
</ul>
Allow/deny rules have this precedence:
<p>
<ul>
<li>
If an allow rule is present, but no deny rule, then if the rule
is satisfied by the current parameter (user agent, IP
number), the client is <b>allowed</b>.
<p>
<li>
If a deny rule is present, but no allow rule, then if the rule
is satisfied by the current parameter, the client is <b>disallowed</b>.
<p>
<li>
If both rules are present, the allow rule is tested, and then the deny rule.
If the allow rule is satisfied, and the deny rule is not, the client is
<b>allowed</b>. Otherwise, the client is <b>disallowed</b>.
<p>
</ul>
In the above example, there is an allow and deny rule for the user agent.
Microsoft Internet Explorer exports a user-agent string of the form
<code>Mozilla/V.v (... MSIE ...)</code>. It will satisfy the allow rule
<code>^Mozilla</code> <i>and</i> the deny rule <code>MSIE</code>, and thus
be <b>disallowed</b>. Netscape Navigator exports a user-agent string of the
form <code>Mozilla/V.v (...)</code>. It will satisfy the allow rule
<code>^Mozilla</code>, but not satisfy the deny rule, and thus will be
<b>allowed</b>. Lynx (<code>Lynx ...</code>) will fail the allow rule and the
deny rule, and will be <b>disallowed</b>.
<p>
The IP address scheme works similarly.
<p>
To add additional restrictions for additional directories, simply add hash
rows with the resource prefix, directory, etc., as the key and the restriction
string as the value to the <code>%restrictions</code> hash -- <b>please
read <a href = "program.html">the programmer's guide</a> for important
information on building new HTTPi versions.</b> Restrictions are prioritized
in descending order by
resource prefix length (i.e. <code>"/foo/bar"</code> takes precedence over
<code>"/foo/"</code> takes precedence over <code>"/"</code>). Naturally, if
no restriction matrix entry exists that matches a particular resource, it
is allowed to all clients and all network addresses.
<p>
When a client is disallowed, it is sent the standard HTTP error code 403,
along with an explanation. With the rule above in place,
<a href = "/nw/">this resource</a>
can only be accessed from <code>ptloma.edu</code> local hosts on the internal
network, and then only by Netscape clients.
<p>
<h3>Questions and Bug Reports</h3>
Send all outstanding issues to <b><a href =
"mailto:httpi@stockholm.ptloma.edu">httpi@stockholm.ptloma.edu</a></b>.
<hr>
<address>Cameron Kaiser</address>
</body>
</html>
