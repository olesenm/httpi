$DEF_MDEMONIC = 1;
$DEF_CONF_TYPE = "Demonic";

eval 'require "consubs.pl";'; die(<<"EOF") if ($@);

Could not load consubs.pl, which is required for running the configure script.
Please make sure it's in the current directory.

EOF

&prompt(<<"EOF", "") unless ($DEFAULT);
Configure (demonic) for HTTPi/0.7 (C)1998, 1999 Cameron Kaiser

This is the configure script for Demonic HTTPi, the daemonized HTTPi version.

THIS VERSION IS EXPERIMENTAL! It does work, and works well -- but it *is*
a radical departure from the old (x)inetd-based version.

DO NOT RUN THIS IF:
	* you have a low tolerance for beta products
	* your Perl doesn't support fork() (currently that's Win32 and a
		few others)
	* you don't have a good idea of how your system implements sockets
	* did I mention this was experimental?

You don't need Socket.pm, though it helps. If you don't have Socket.pm, I'll
need a C compiler to determine what your socket constants are. (Or I could
ask you, but do you really keep SOMAXCONN in your head?)

Press ENTER to continue or BREAK/CTRL-C to bail out:
EOF

print "\nChecking system defaults ...\n\n";
$DEF_UNAME = &wherecheck("Finding uname", "uname");
if ($DEF_UNAME) {
	chomp($DEF_ARCH = `$DEF_UNAME -s`);
	print "Smells like $DEF_ARCH.\n";
} else {
	print "Hmm. This might not be a Unix box, but we'll keep trying.\n";
	$DEF_ARCH = "???";
}
$q = &yncheck("Can we fork()?",
	'if ($pid = fork()) { waitpid($pid,0); } else { exit; }',
	<<"EOF");

Sorry -- we need to be able to fork() in order to get proper process
isolation. You'd have a very unstable HTTPi otherwise. Please run this on
a proper OS. :-)

EOF

$DEF_PERL = &wherecheck("Finding your perl", "perl", <<"EOF");

Good grief, you've managed to run this with Perl not in your path. Where
the heck is it, anyway? Put Perl in your path and rerun.

EOF

eval 'require "conquests.pl";'; die(<<"EOF") if ($@);

Could not load conquests.pl, which is required as part of the standard
questions suite for all of the configure scripts. Please make sure it's in
the current directory.

EOF

$DEF_IP_ADDR = &prompt(<<"EOF", "0.0.0.0", 1);
What numerical IP address do you want the webserver to bind to? You can run
multiple HTTPis bound to multiple addresses this way for virtual servers
(currently the IP-less Host:-selected virtual server option is not supported
by HTTPi).

0.0.0.0, the default, will bind to whatever address it can find. This is
usually fine for most systems, and should only be changed if you are in fact
trying to use HTTPi to support virtual servers.

Bind to which numerical IP address?
EOF

$DEF_INADDR_ANY = 'pack("l", "\0\0\0\0")';
if (($o1, $o2, $o3, $o4) = split(/\./, $DEF_IP_ADDR)) {
	$DEF_INADDR_ANY = "pack('l', chr($o1).chr($o2).chr($o3).chr($o4))";
}
$DEF_IP_ADDR = "ANY" if ($DEF_IP_ADDR eq '0.0.0.0');

$DEF_TCP_PORT = &prompt(<<"EOF", "80", 1);
What numerical TCP port do you want the webserver to run on? 80 is the default
but if you're using configure to build multiple HTTPis on multiple ports,
make sure you give a different answer this time.

Remember that port numbers below 1024 can only be bound by processes running
as superuser! (That's kind of a security hole, for any webserver even.)

Which TCP port number?
EOF


print <<"EOF";
Now the tricky part. Let's see if your Perl knows your socket constants.
Usually they're given in Socket.pm somewhere.

Trying to run $DEF_PERL ./sockcons.pl ...

EOF
undef $cons;
if (open(S, "$DEF_PERL ./sockcons.pl|")) {
	while(<S>) {
		chomp;
		($cons, $DEF_AF_INET, $DEF_PF_INET, $DEF_SOCK_STREAM,
			$DEF_SOL_SOCKET, $DEF_SO_REUSEADDR, $DEF_SOMAXCONN,
			$DEF_IPPROTO_TCP) =
				split(/ /, $_);
	}
	close(S);
}

if ($cons ne 'cons') {
	print <<"EOF";

Drat. Let's see if you have a C compiler.

EOF
	$CC = &wherecheck("Finding gcc", "gcc");
	$CC = &wherecheck("Darn. Let's try cc", "cc") unless ($CC);
	if (!$CC) {
		$CC = &prompt(<<"EOF", "none", 1);

Okay, where the heck *is* your C compiler? If you don't have one, and want
to try entering them in by hand, enter none (the default). If you *do* have
one that I'm just unable to find, enter the absolute path below.

Path to C compiler?
EOF
	}
	if ($CC ne 'none') {
		print <<"EOF";

Trying $CC ./sockcons.c -o sockcons ...

EOF
		unlink("./sockcons"); # just to be sure it really compiles
		system("$CC ./sockcons.c -o ./sockcons");
		if (open(S, "./sockcons|")) {
			while(<S>) {
				chomp;
		($cons, $DEF_AF_INET, $DEF_PF_INET, $DEF_SOCK_STREAM,
			$DEF_SOL_SOCKET, $DEF_SO_REUSEADDR, $DEF_SOMAXCONN,
			$DEF_IPPROTO_TCP) =
				split(/ /, $_);
			}
			close(S);
		}
	}
	print "Still doesn't work! Darn, darn and double darn!\n"
		if ($cons ne 'cons');
}

if ($cons eq 'cons') {
	if (!$DEF_IPPROTO_TCP) { # freaking broken Socket.pm
		$q = <<"EOF";

(I had to mess with your IPPROTO_TCP, because your system reported a 0
originally. It's usually six, but this probably doesn't matter. Socket.pm
apparently doesn't know what it is.)

EOF
		$DEF_IPPROTO_TCP = 6;
	} else { $q = ''; }
	$j = prompt(<<"EOF", "");

Yay, got something back! This is what your system is reporting:

AF_INET = $DEF_AF_INET
PF_INET = $DEF_PF_INET
SOCK_STREAM = $DEF_SOCK_STREAM
SOL_SOCKET = $DEF_SOL_SOCKET
SO_REUSEADDR = $DEF_SO_REUSEADDR
SOMAXCONN = $DEF_SOMAXCONN
IPPROTO_TCP = $DEF_IPPROTO_TCP
$q
If this isn't right, hit CTRL-C now. Something's wrong. Otherwise, just
hit ENTER:
EOF
} else {
	$DEF_AF_INET = &prompt(<<"EOF", 2, 1);
Okay, you'll need to enter them manually.

Most of the time, I can guess your constants right. Linux seems to have funny
ones (but this isn't generally a problem because any worthwhile Linux
distribution ought to have a full Perl package and/or gcc). If you don't know
what these values should be, they are normally in <sys/socket.h> and
<netinet/in.h>.

AF_INET?
EOF
	$DEF_PF_INET = &prompt("PF_INET?\n", 2, 1);
	$DEF_SOCK_STREAM = &prompt("SOCK_STREAM?\n", 1, 1);
	$DEF_SOL_SOCKET = &prompt("SOL_SOCKET?\n", 65535, 1);
	$DEF_SO_REUSEADDR = &prompt("SO_REUSEADDR?\n", 4, 1);
	$DEF_SOMAXCONN = &prompt("SOMAXCONN?\n", 5, 1);
	$DEF_IPPROTO_TCP = &prompt("IPPROTO_TCP?\n", 6, 1);
}


$j = &prompt(<<"EOF", "");

LAST CHANCE BEFORE CHANGES ARE COMMITTED!

If you continue beyond this point, configure will build your HTTPi and
overwrite any file currently at $INSTALL_PATH.

If you want to continue, just press ENTER.
If you don't, press CTRL-C NOW!
EOF

print "Writing out the configured httpi to $INSTALL_PATH ... ";
&preproc("httpi.in", "$INSTALL_PATH", <<"EOF");

Couldn't write out the new httpi. Check permissions on httpi.in in the
current directory (you *are* root, right?) and the destination path.

EOF
print "done.\n\n";

print "chmod()ding $INSTALL_PATH to 0755 ... ";
chmod 0755, "$INSTALL_PATH" || die("\n\nWhat the heck? Can't do it.\n");
print "done.\n\n";

print <<"EOF";
Successfully configured!

Invoke your new HTTPi with a simple

$INSTALL_PATH

No & required. Remember: if it's binding to a port < 1024, you'll need to
be root, and that may not be a good thing with this relatively untested.
If you want a root-reliable HTTPi, you're better off with the inetd versions
for right now (though to be fair I run Demonic HTTPi, of course).

Remember to read the documentation file for last minute information. Bye!

EOF
